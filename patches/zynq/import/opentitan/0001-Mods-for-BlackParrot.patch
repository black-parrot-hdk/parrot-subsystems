From 464ba329ca56267c47d70899edef950dd8f38f5f Mon Sep 17 00:00:00 2001
From: Dan Petrisko <petrisko@cs.washington.edu>
Date: Fri, 23 Aug 2024 14:42:22 -0700
Subject: [PATCH] Mods for BlackParrot

---
 hw/dv/dpi/common/tcp_server/tcp_server.c | 567 +++++++++++------------
 hw/dv/dpi/dmidpi/dmidpi.c                | 748 ++++++++++++++++++-------------
 hw/dv/dpi/dmidpi/dmidpi.h                |   2 +-
 hw/dv/dpi/dmidpi/dmidpi.sv               |   8 +-
 4 files changed, 723 insertions(+), 602 deletions(-)

diff --git a/hw/dv/dpi/common/tcp_server/tcp_server.c b/hw/dv/dpi/common/tcp_server/tcp_server.c
index 4d42665..98f50ad 100644
--- a/hw/dv/dpi/common/tcp_server/tcp_server.c
+++ b/hw/dv/dpi/common/tcp_server/tcp_server.c
@@ -29,70 +29,70 @@
 #define BUFSIZE_BYTE 256
 
 struct tcp_buf {
-  unsigned int rptr;
-  unsigned int wptr;
-  char buf[BUFSIZE_BYTE];
+    unsigned int rptr;
+    unsigned int wptr;
+    char buf[BUFSIZE_BYTE];
 };
 
 /**
  * TCP Server thread context structure
  */
 struct tcp_server_ctx {
-  // Writeable by the host thread
-  char *display_name;
-  uint16_t listen_port;
-  volatile bool socket_run;
-  // Writeable by the server thread
-  struct tcp_buf *buf_in;
-  struct tcp_buf *buf_out;
-  int sfd;  // socket fd
-  int cfd;  // client fd
-  pthread_t sock_thread;
+    // Writeable by the host thread
+    char *display_name;
+    uint16_t listen_port;
+    volatile bool socket_run;
+    // Writeable by the server thread
+    struct tcp_buf *buf_in;
+    struct tcp_buf *buf_out;
+    int sfd;  // socket fd
+    int cfd;  // client fd
+    pthread_t sock_thread;
 };
 
 static bool tcp_buffer_is_full(struct tcp_buf *buf) {
-  if (buf->wptr >= buf->rptr) {
-    return (buf->wptr - buf->rptr) == (BUFSIZE_BYTE - 1);
-  } else {
-    return (buf->rptr - buf->wptr) == 1;
-  }
+    if (buf->wptr >= buf->rptr) {
+        return (buf->wptr - buf->rptr) == (BUFSIZE_BYTE - 1);
+    } else {
+        return (buf->rptr - buf->wptr) == 1;
+    }
 }
 
 static bool tcp_buffer_is_empty(struct tcp_buf *buf) {
-  return (buf->wptr == buf->rptr);
+    return (buf->wptr == buf->rptr);
 }
 
 static void tcp_buffer_put_byte(struct tcp_buf *buf, char dat) {
-  bool done = false;
-  while (!done) {
-    if (!tcp_buffer_is_full(buf)) {
-      buf->buf[buf->wptr++] = dat;
-      buf->wptr %= BUFSIZE_BYTE;
-      done = true;
+    bool done = false;
+    while (!done) {
+        if (!tcp_buffer_is_full(buf)) {
+            buf->buf[buf->wptr++] = dat;
+            buf->wptr %= BUFSIZE_BYTE;
+            done = true;
+        }
     }
-  }
 }
 
 static bool tcp_buffer_get_byte(struct tcp_buf *buf, char *dat) {
-  if (tcp_buffer_is_empty(buf)) {
-    return false;
-  }
-  *dat = buf->buf[buf->rptr++];
-  buf->rptr %= BUFSIZE_BYTE;
-  return true;
+    if (tcp_buffer_is_empty(buf)) {
+        return false;
+    }
+    *dat = buf->buf[buf->rptr++];
+    buf->rptr %= BUFSIZE_BYTE;
+    return true;
 }
 
 static struct tcp_buf *tcp_buffer_new(void) {
-  struct tcp_buf *buf_new;
-  buf_new = (struct tcp_buf *)malloc(sizeof(struct tcp_buf));
-  buf_new->rptr = 0;
-  buf_new->wptr = 0;
-  return buf_new;
+    struct tcp_buf *buf_new;
+    buf_new = (struct tcp_buf *)malloc(sizeof(struct tcp_buf));
+    buf_new->rptr = 0;
+    buf_new->wptr = 0;
+    return buf_new;
 }
 
 static void tcp_buffer_free(struct tcp_buf **buf) {
-  free(*buf);
-  *buf = NULL;
+    free(*buf);
+    *buf = NULL;
 }
 
 /**
@@ -105,70 +105,70 @@ static void tcp_buffer_free(struct tcp_buf **buf) {
  * @return 0 on success, -1 in case of an error
  */
 static int start(struct tcp_server_ctx *ctx) {
-  int rv;
-
-  assert(ctx->sfd == 0 && "Server already started.");
-
-  // create socket
-  int sfd = socket(AF_INET, SOCK_STREAM, 0);
-  if (sfd == -1) {
-    fprintf(stderr, "%s: Unable to create socket: %s (%d)\n", ctx->display_name,
-            strerror(errno), errno);
-    return -1;
-  }
-
-  rv = fcntl(sfd, F_SETFL, O_NONBLOCK);
-  if (rv != 0) {
-    fprintf(stderr, "%s: Unable to make socket non-blocking: %s (%d)\n",
-            ctx->display_name, strerror(errno), errno);
-    return -1;
-  }
-
-  // reuse existing socket (if existing)
-  int reuse_socket = 1;
-  rv = setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &reuse_socket, sizeof(int));
-  if (rv != 0) {
-    fprintf(stderr, "%s: Unable to set socket options: %s (%d)\n",
-            ctx->display_name, strerror(errno), errno);
-    return -1;
-  }
-
-  // stop tcp socket from buffering (buffering prevents timely responses to
-  // OpenOCD which severly limits debugging performance)
-  int tcp_nodelay = 1;
-  rv = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, &tcp_nodelay, sizeof(int));
-  if (rv != 0) {
-    fprintf(stderr, "%s: Unable to set socket nodelay: %s (%d)\n",
-            ctx->display_name, strerror(errno), errno);
-    return -1;
-  }
-
-  // bind server
-  struct sockaddr_in addr;
-  memset(&addr, 0, sizeof(addr));
-  addr.sin_family = AF_INET;
-  addr.sin_addr.s_addr = htonl(INADDR_ANY);
-  addr.sin_port = htons(ctx->listen_port);
-
-  rv = bind(sfd, (struct sockaddr *)&addr, sizeof(addr));
-  if (rv != 0) {
-    fprintf(stderr, "%s: Failed to bind socket: %s (%d)\n", ctx->display_name,
-            strerror(errno), errno);
-    return -1;
-  }
-
-  // listen for incoming connections
-  rv = listen(sfd, 1);
-  if (rv != 0) {
-    fprintf(stderr, "%s: Failed to listen on socket: %s (%d)\n",
-            ctx->display_name, strerror(errno), errno);
-    return -1;
-  }
-
-  ctx->sfd = sfd;
-  assert(ctx->sfd > 0);
-
-  return 0;
+    int rv;
+
+    assert(ctx->sfd == 0 && "Server already started.");
+
+    // create socket
+    int sfd = socket(AF_INET, SOCK_STREAM, 0);
+    if (sfd == -1) {
+        fprintf(stderr, "%s: Unable to create socket: %s (%d)\n",
+                ctx->display_name, strerror(errno), errno);
+        return -1;
+    }
+
+    rv = fcntl(sfd, F_SETFL, O_NONBLOCK);
+    if (rv != 0) {
+        fprintf(stderr, "%s: Unable to make socket non-blocking: %s (%d)\n",
+                ctx->display_name, strerror(errno), errno);
+        return -1;
+    }
+
+    // reuse existing socket (if existing)
+    int reuse_socket = 1;
+    rv = setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, &reuse_socket, sizeof(int));
+    if (rv != 0) {
+        fprintf(stderr, "%s: Unable to set socket options: %s (%d)\n",
+                ctx->display_name, strerror(errno), errno);
+        return -1;
+    }
+
+    // stop tcp socket from buffering (buffering prevents timely responses to
+    // OpenOCD which severly limits debugging performance)
+    int tcp_nodelay = 1;
+    rv = setsockopt(sfd, IPPROTO_TCP, TCP_NODELAY, &tcp_nodelay, sizeof(int));
+    if (rv != 0) {
+        fprintf(stderr, "%s: Unable to set socket nodelay: %s (%d)\n",
+                ctx->display_name, strerror(errno), errno);
+        return -1;
+    }
+
+    // bind server
+    struct sockaddr_in addr;
+    memset(&addr, 0, sizeof(addr));
+    addr.sin_family = AF_INET;
+    addr.sin_addr.s_addr = htonl(INADDR_ANY);
+    addr.sin_port = htons(ctx->listen_port);
+
+    rv = bind(sfd, (struct sockaddr *)&addr, sizeof(addr));
+    if (rv != 0) {
+        fprintf(stderr, "%s: Failed to bind socket: %s (%d)\n",
+                ctx->display_name, strerror(errno), errno);
+        return -1;
+    }
+
+    // listen for incoming connections
+    rv = listen(sfd, 1);
+    if (rv != 0) {
+        fprintf(stderr, "%s: Failed to listen on socket: %s (%d)\n",
+                ctx->display_name, strerror(errno), errno);
+        return -1;
+    }
+
+    ctx->sfd = sfd;
+    assert(ctx->sfd > 0);
+
+    return 0;
 }
 
 /**
@@ -180,36 +180,37 @@ static int start(struct tcp_server_ctx *ctx) {
  * @return 0 on success, any other value indicates an error
  */
 static int client_tryaccept(struct tcp_server_ctx *ctx) {
-  int rv;
+    int rv;
 
-  assert(ctx->sfd > 0);
-  assert(ctx->cfd == 0);
+    assert(ctx->sfd > 0);
+    assert(ctx->cfd == 0);
 
-  int cfd = accept(ctx->sfd, NULL, NULL);
+    int cfd = accept(ctx->sfd, NULL, NULL);
 
-  if (cfd == -1 && errno == EAGAIN) {
-    return -EAGAIN;
-  }
+    if (cfd == -1 && errno == EAGAIN) {
+        return -EAGAIN;
+    }
 
-  if (cfd == -1) {
-    fprintf(stderr, "%s: Unable to accept incoming connection: %s (%d)\n",
-            ctx->display_name, strerror(errno), errno);
-    return -1;
-  }
+    if (cfd == -1) {
+        fprintf(stderr, "%s: Unable to accept incoming connection: %s (%d)\n",
+                ctx->display_name, strerror(errno), errno);
+        return -1;
+    }
 
-  rv = fcntl(cfd, F_SETFL, O_NONBLOCK);
-  if (rv != 0) {
-    fprintf(stderr, "%s: Unable to make client socket non-blocking: %s (%d)\n",
-            ctx->display_name, strerror(errno), errno);
-    return -1;
-  }
+    rv = fcntl(cfd, F_SETFL, O_NONBLOCK);
+    if (rv != 0) {
+        fprintf(stderr,
+                "%s: Unable to make client socket non-blocking: %s (%d)\n",
+                ctx->display_name, strerror(errno), errno);
+        return -1;
+    }
 
-  ctx->cfd = cfd;
-  assert(ctx->cfd > 0);
+    ctx->cfd = cfd;
+    assert(ctx->cfd > 0);
 
-  printf("%s: Accepted client connection\n", ctx->display_name);
+    printf("%s: Accepted client connection\n", ctx->display_name);
 
-  return 0;
+    return 0;
 }
 
 /**
@@ -218,12 +219,12 @@ static int client_tryaccept(struct tcp_server_ctx *ctx) {
  * @param ctx context object
  */
 static void stop(struct tcp_server_ctx *ctx) {
-  assert(ctx);
-  if (!ctx->sfd) {
-    return;
-  }
-  close(ctx->sfd);
-  ctx->sfd = 0;
+    assert(ctx);
+    if (!ctx->sfd) {
+        return;
+    }
+    close(ctx->sfd);
+    ctx->sfd = 0;
 }
 
 /**
@@ -234,29 +235,29 @@ static void stop(struct tcp_server_ctx *ctx) {
  * @return true if a byte was read
  */
 static bool get_byte(struct tcp_server_ctx *ctx, char *cmd) {
-  assert(ctx);
-
-  ssize_t num_read = read(ctx->cfd, cmd, 1);
-
-  if (num_read == 0) {
-    return false;
-  }
-  if (num_read == -1) {
-    if (errno == EAGAIN || errno == EWOULDBLOCK) {
-      return false;
-    } else if (errno == EBADF) {
-      // Possibly client went away? Accept a new connection.
-      fprintf(stderr, "%s: Client disappeared.\n", ctx->display_name);
-      tcp_server_client_close(ctx);
-      return false;
-    } else {
-      fprintf(stderr, "%s: Error while reading from client: %s (%d)\n",
-              ctx->display_name, strerror(errno), errno);
-      assert(0 && "Error reading from client");
+    assert(ctx);
+
+    ssize_t num_read = read(ctx->cfd, cmd, 1);
+
+    if (num_read == 0) {
+        return false;
     }
-  }
-  assert(num_read == 1);
-  return true;
+    if (num_read == -1) {
+        if (errno == EAGAIN || errno == EWOULDBLOCK) {
+            return false;
+        } else if (errno == EBADF) {
+            // Possibly client went away? Accept a new connection.
+            fprintf(stderr, "%s: Client disappeared.\n", ctx->display_name);
+            tcp_server_client_close(ctx);
+            return false;
+        } else {
+            fprintf(stderr, "%s: Error while reading from client: %s (%d)\n",
+                    ctx->display_name, strerror(errno), errno);
+            assert(0 && "Error reading from client");
+        }
+    }
+    assert(num_read == 1);
+    return true;
 }
 
 /**
@@ -266,25 +267,25 @@ static bool get_byte(struct tcp_server_ctx *ctx, char *cmd) {
  * @param cmd byte to send
  */
 static void put_byte(struct tcp_server_ctx *ctx, char cmd) {
-  while (1) {
-    ssize_t num_written = send(ctx->cfd, &cmd, sizeof(cmd), MSG_NOSIGNAL);
-    if (num_written == -1) {
-      if (errno == EAGAIN || errno == EWOULDBLOCK) {
-        continue;
-      } else if (errno == EPIPE) {
-        printf("%s: Remote disconnected.\n", ctx->display_name);
-        tcp_server_client_close(ctx);
-        break;
-      } else {
-        fprintf(stderr, "%s: Error while writing to client: %s (%d)\n",
-                ctx->display_name, strerror(errno), errno);
-        assert(0 && "Error writing to client.");
-      }
+    while (1) {
+        ssize_t num_written = send(ctx->cfd, &cmd, sizeof(cmd), MSG_NOSIGNAL);
+        if (num_written == -1) {
+            if (errno == EAGAIN || errno == EWOULDBLOCK) {
+                continue;
+            } else if (errno == EPIPE) {
+                printf("%s: Remote disconnected.\n", ctx->display_name);
+                tcp_server_client_close(ctx);
+                break;
+            } else {
+                fprintf(stderr, "%s: Error while writing to client: %s (%d)\n",
+                        ctx->display_name, strerror(errno), errno);
+                assert(0 && "Error writing to client.");
+            }
+        }
+        if (num_written >= 1) {
+            break;
+        }
     }
-    if (num_written >= 1) {
-      break;
-    }
-  }
 }
 
 /**
@@ -293,14 +294,14 @@ static void put_byte(struct tcp_server_ctx *ctx, char cmd) {
  * @param ctx context object
  */
 static void ctx_free(struct tcp_server_ctx *ctx) {
-  // Free the buffers
-  tcp_buffer_free(&ctx->buf_in);
-  tcp_buffer_free(&ctx->buf_out);
-  // Free the display name
-  free(ctx->display_name);
-  // Free the ctx
-  free(ctx);
-  ctx = NULL;
+    // Free the buffers
+    tcp_buffer_free(&ctx->buf_in);
+    tcp_buffer_free(&ctx->buf_out);
+    // Free the display name
+    free(ctx->display_name);
+    // Free the ctx
+    free(ctx);
+    ctx = NULL;
 }
 
 /**
@@ -310,134 +311,134 @@ static void ctx_free(struct tcp_server_ctx *ctx) {
  * @return Always returns NULL
  */
 static void *server_create(void *ctx_void) {
-  // Cast to a server struct
-  struct tcp_server_ctx *ctx = (struct tcp_server_ctx *)ctx_void;
-  struct timeval timeout;
-
-  // Start the server
-  int rv = start(ctx);
-  if (rv != 0) {
-    fprintf(stderr, "%s: Unable to create TCP server on port %d\n",
-            ctx->display_name, ctx->listen_port);
-    goto err_cleanup_return;
-  }
-
-  // Initialise timeout
-  timeout.tv_sec = 0;
-
-  // Initialise fd_set
-
-  // Start waiting for connection / data
-  char xfer_data;
-  while (ctx->socket_run) {
-    // Initialise structure of fds
-    fd_set read_fds;
-    FD_ZERO(&read_fds);
-    if (ctx->sfd) {
-      FD_SET(ctx->sfd, &read_fds);
+    // Cast to a server struct
+    struct tcp_server_ctx *ctx = (struct tcp_server_ctx *)ctx_void;
+    struct timeval timeout;
+
+    // Start the server
+    int rv = start(ctx);
+    if (rv != 0) {
+        fprintf(stderr, "%s: Unable to create TCP server on port %d\n",
+                ctx->display_name, ctx->listen_port);
+        goto err_cleanup_return;
     }
-    if (ctx->cfd) {
-      FD_SET(ctx->cfd, &read_fds);
-    }
-    // max fd num
-    int mfd = (ctx->cfd > ctx->sfd) ? ctx->cfd : ctx->sfd;
-
-    // Set timeout - 50us gives good performance
-    timeout.tv_usec = 50;
-
-    // Wait for socket activity or timeout
-    rv = select(mfd + 1, &read_fds, NULL, NULL, &timeout);
 
-    if (rv < 0) {
-      printf("%s: Socket read failed, port: %d\n", ctx->display_name,
-             ctx->listen_port);
-      tcp_server_client_close(ctx);
+    // Initialise timeout
+    timeout.tv_sec = 0;
+
+    // Initialise fd_set
+
+    // Start waiting for connection / data
+    char xfer_data;
+    while (ctx->socket_run) {
+        // Initialise structure of fds
+        fd_set read_fds;
+        FD_ZERO(&read_fds);
+        if (ctx->sfd) {
+            FD_SET(ctx->sfd, &read_fds);
+        }
+        if (ctx->cfd) {
+            FD_SET(ctx->cfd, &read_fds);
+        }
+        // max fd num
+        int mfd = (ctx->cfd > ctx->sfd) ? ctx->cfd : ctx->sfd;
+
+        // Set timeout - 50us gives good performance
+        timeout.tv_usec = 50;
+
+        // Wait for socket activity or timeout
+        rv = select(mfd + 1, &read_fds, NULL, NULL, &timeout);
+
+        if (rv < 0) {
+            printf("%s: Socket read failed, port: %d\n", ctx->display_name,
+                   ctx->listen_port);
+            tcp_server_client_close(ctx);
+        }
+
+        // New connection
+        if (FD_ISSET(ctx->sfd, &read_fds)) {
+            client_tryaccept(ctx);
+        }
+
+        // New client data
+        if (FD_ISSET(ctx->cfd, &read_fds)) {
+            while (get_byte(ctx, &xfer_data)) {
+                tcp_buffer_put_byte(ctx->buf_in, xfer_data);
+            }
+        }
+
+        if (ctx->cfd != 0) {
+            while (tcp_buffer_get_byte(ctx->buf_out, &xfer_data)) {
+                put_byte(ctx, xfer_data);
+            }
+        }
     }
 
-    // New connection
-    if (FD_ISSET(ctx->sfd, &read_fds)) {
-      client_tryaccept(ctx);
-    }
-
-    // New client data
-    if (FD_ISSET(ctx->cfd, &read_fds)) {
-      while (get_byte(ctx, &xfer_data)) {
-        tcp_buffer_put_byte(ctx->buf_in, xfer_data);
-      }
-    }
-
-    if (ctx->cfd != 0) {
-      while (tcp_buffer_get_byte(ctx->buf_out, &xfer_data)) {
-        put_byte(ctx, xfer_data);
-      }
-    }
-  }
-
 err_cleanup_return:
 
-  // Simulation done - clean up
-  tcp_server_client_close(ctx);
-  stop(ctx);
+    // Simulation done - clean up
+    tcp_server_client_close(ctx);
+    stop(ctx);
 
-  return NULL;
+    return NULL;
 }
 
 // Abstract interface functions
 struct tcp_server_ctx *tcp_server_create(const char *display_name,
                                          int listen_port) {
-  struct tcp_server_ctx *ctx =
-      (struct tcp_server_ctx *)calloc(1, sizeof(struct tcp_server_ctx));
-  assert(ctx);
-
-  // Create the buffers
-  struct tcp_buf *buf_in = tcp_buffer_new();
-  struct tcp_buf *buf_out = tcp_buffer_new();
-  assert(buf_in);
-  assert(buf_out);
-
-  // Populate the struct with buffer pointers
-  ctx->buf_in = buf_in;
-  ctx->buf_out = buf_out;
-
-  // Set up socket details
-  ctx->socket_run = true;
-  ctx->listen_port = listen_port;
-  ctx->display_name = strdup(display_name);
-  assert(ctx->display_name);
-
-  if (pthread_create(&ctx->sock_thread, NULL, server_create, (void *)ctx) !=
-      0) {
-    fprintf(stderr, "%s: Unable to create TCP socket thread\n",
-            ctx->display_name);
-    ctx_free(ctx);
-    free(ctx);
-    return NULL;
-  }
-  return ctx;
+    struct tcp_server_ctx *ctx =
+        (struct tcp_server_ctx *)calloc(1, sizeof(struct tcp_server_ctx));
+    assert(ctx);
+
+    // Create the buffers
+    struct tcp_buf *buf_in = tcp_buffer_new();
+    struct tcp_buf *buf_out = tcp_buffer_new();
+    assert(buf_in);
+    assert(buf_out);
+
+    // Populate the struct with buffer pointers
+    ctx->buf_in = buf_in;
+    ctx->buf_out = buf_out;
+
+    // Set up socket details
+    ctx->socket_run = true;
+    ctx->listen_port = listen_port;
+    ctx->display_name = strdup(display_name);
+    assert(ctx->display_name);
+
+    if (pthread_create(&ctx->sock_thread, NULL, server_create, (void *)ctx) !=
+        0) {
+        fprintf(stderr, "%s: Unable to create TCP socket thread\n",
+                ctx->display_name);
+        ctx_free(ctx);
+        free(ctx);
+        return NULL;
+    }
+    return ctx;
 }
 
 bool tcp_server_read(struct tcp_server_ctx *ctx, char *dat) {
-  return tcp_buffer_get_byte(ctx->buf_in, dat);
+    return tcp_buffer_get_byte(ctx->buf_in, dat);
 }
 
 void tcp_server_write(struct tcp_server_ctx *ctx, char dat) {
-  tcp_buffer_put_byte(ctx->buf_out, dat);
+    tcp_buffer_put_byte(ctx->buf_out, dat);
 }
 
 void tcp_server_close(struct tcp_server_ctx *ctx) {
-  // Shut down the socket thread
-  ctx->socket_run = false;
-  pthread_join(ctx->sock_thread, NULL);
-  ctx_free(ctx);
+    // Shut down the socket thread
+    ctx->socket_run = false;
+    pthread_join(ctx->sock_thread, NULL);
+    ctx_free(ctx);
 }
 
 void tcp_server_client_close(struct tcp_server_ctx *ctx) {
-  assert(ctx);
+    assert(ctx);
 
-  if (!ctx->cfd) {
-    return;
-  }
+    if (!ctx->cfd) {
+        return;
+    }
 
-  close(ctx->cfd);
-  ctx->cfd = 0;
+    close(ctx->cfd);
+    ctx->cfd = 0;
 }
diff --git a/hw/dv/dpi/dmidpi/dmidpi.c b/hw/dv/dpi/dmidpi/dmidpi.c
index bce78f0..4d2b71e 100644
--- a/hw/dv/dpi/dmidpi/dmidpi.c
+++ b/hw/dv/dpi/dmidpi/dmidpi.c
@@ -32,60 +32,83 @@ const int IDCODEVAL = 0x04F5484D;
 const int DTMCSRVAL = 0x00000071;
 
 enum jtag_state_t {
-  TestLogicReset,
-  RunTestIdle,
-  SelectDrScan,
-  CaptureDr,
-  ShiftDr,
-  Exit1Dr,
-  PauseDr,
-  Exit2Dr,
-  UpdateDr,
-  SelectIrScan,
-  CaptureIr,
-  ShiftIr,
-  Exit1Ir,
-  PauseIr,
-  Exit2Ir,
-  UpdateIr
+    TestLogicReset,
+    RunTestIdle,
+    SelectDrScan,
+    CaptureDr,
+    ShiftDr,
+    Exit1Dr,
+    PauseDr,
+    Exit2Dr,
+    UpdateDr,
+    SelectIrScan,
+    CaptureIr,
+    ShiftIr,
+    Exit1Ir,
+    PauseIr,
+    Exit2Ir,
+    UpdateIr
 };
 
 enum jtag_reg_t {
-  Bypass0 = 0x0,
-  IdCode = 0x1,
-  DTMCSR = 0x10,
-  DMIAccess = 0x11,
-  Bypass1 = 0x1f
+    Bypass0 = 0x0,
+    IdCode = 0x1,
+    DTMCSR = 0x10,
+    DMIAccess = 0x11,
+    Bypass1 = 0x1f
 };
 
 struct jtag_ctx {
-  uint32_t ir_shift_reg;
-  uint64_t dr_shift_reg;
-  uint32_t ir_captured;
-  uint64_t dr_captured;
-  uint8_t dr_length;
-  uint8_t jtag_tdo;
-  enum jtag_state_t jtag_state;
-  uint8_t dmi_outstanding;
+    uint32_t ir_shift_reg;
+    uint64_t dr_shift_reg;
+    uint32_t ir_captured;
+    uint64_t dr_captured;
+    uint8_t dr_length;
+    uint8_t jtag_tdo;
+    enum jtag_state_t jtag_state;
+    uint8_t dmi_outstanding;
 };
 
 struct dmi_sig_values {
-  uint8_t dmi_req_valid;
-  uint8_t dmi_req_ready;
-  uint32_t dmi_req_addr;
-  uint32_t dmi_req_op;
-  uint32_t dmi_req_data;
-  uint8_t dmi_rsp_valid;
-  uint8_t dmi_rsp_ready;
-  uint32_t dmi_rsp_data;
-  uint32_t dmi_rsp_resp;
-  uint8_t dmi_rst_n;
+    uint8_t dmi_req_valid;
+    uint8_t dmi_req_ready;
+    uint32_t dmi_req_addr;
+    uint32_t dmi_req_op;
+    uint32_t dmi_req_data;
+    uint8_t dmi_rsp_valid;
+    uint8_t dmi_rsp_ready;
+    uint32_t dmi_rsp_data;
+    uint32_t dmi_rsp_resp;
+    uint8_t dmi_rst_n;
+};
+
+enum dtm_state_t {
+    Ready = 0x0,
+    StartReq = 0x1,
+    SbaCfg = 0x2,
+    SendNPC_A = 0x3,
+    SendNPC_D = 0x4,
+    SendHiReq_A = 0x5,
+    SendHiReq_D = 0x6,
+    SendLoReq_A = 0x7,
+    SendLoReq_D = 0x8,
+    SendUnfreeze_A = 0x9,
+    SendUnfreeze_D = 0xA,
+    EndReq = 0xB
+};
+
+struct dtm_ctx {
+    uint8_t dmi_outstanding;
+    uint8_t dmi_captured;
+    uint8_t dmi_timeout;
+    enum dtm_state_t dtm_state;
 };
 
 struct dmidpi_ctx {
-  struct tcp_server_ctx *sock;
-  struct jtag_ctx jtag;
-  struct dmi_sig_values sig;
+    struct tcp_server_ctx *sock;
+    struct jtag_ctx jtag;
+    struct dtm_ctx dtm;
+    struct dmi_sig_values sig;
 };
 
 /**
@@ -94,24 +117,24 @@ struct dmidpi_ctx {
  * @param ctx dmidpi context object
  */
 static void set_dr_data(struct dmidpi_ctx *ctx) {
-  switch (ctx->jtag.ir_captured) {
-    case Bypass0:
-    case Bypass1:
-      ctx->jtag.dr_shift_reg = 0;
-      ctx->jtag.dr_length = 1;
-      break;
-    case IdCode:
-      ctx->jtag.dr_shift_reg = IDCODEVAL;
-      ctx->jtag.dr_length = 32;
-      break;
-    case DTMCSR:
-      ctx->jtag.dr_shift_reg = DTMCSRVAL;
-      ctx->jtag.dr_length = 32;
-      break;
-    case DMIAccess:
-      ctx->jtag.dr_shift_reg = ctx->jtag.dr_captured;
-      ctx->jtag.dr_length = 32 + 7 + 2;
-  }
+    switch (ctx->jtag.ir_captured) {
+        case Bypass0:
+        case Bypass1:
+            ctx->jtag.dr_shift_reg = 0;
+            ctx->jtag.dr_length = 1;
+            break;
+        case IdCode:
+            ctx->jtag.dr_shift_reg = IDCODEVAL;
+            ctx->jtag.dr_length = 32;
+            break;
+        case DTMCSR:
+            ctx->jtag.dr_shift_reg = DTMCSRVAL;
+            ctx->jtag.dr_length = 32;
+            break;
+        case DMIAccess:
+            ctx->jtag.dr_shift_reg = ctx->jtag.dr_captured;
+            ctx->jtag.dr_length = 32 + 7 + 2;
+    }
 }
 
 /**
@@ -119,12 +142,12 @@ static void set_dr_data(struct dmidpi_ctx *ctx) {
  *
  * @param ctx dmidpi context object
  */
-static void issue_dmi_req(struct dmidpi_ctx *ctx) {
-  ctx->jtag.dmi_outstanding = 1;
-  ctx->sig.dmi_req_valid = 1;
-  ctx->sig.dmi_req_addr = (ctx->jtag.dr_captured >> 34) & 0x7F;
-  ctx->sig.dmi_req_op = ctx->jtag.dr_captured & 0x3;
-  ctx->sig.dmi_req_data = (ctx->jtag.dr_captured >> 2) & 0xFFFFFFFF;
+static void issue_jtag_dmi_req(struct dmidpi_ctx *ctx) {
+    ctx->jtag.dmi_outstanding = 1;
+    ctx->sig.dmi_req_valid = 1;
+    ctx->sig.dmi_req_addr = (ctx->jtag.dr_captured >> 34) & 0x7F;
+    ctx->sig.dmi_req_op = ctx->jtag.dr_captured & 0x3;
+    ctx->sig.dmi_req_data = (ctx->jtag.dr_captured >> 2) & 0xFFFFFFFF;
 }
 
 /**
@@ -136,139 +159,139 @@ static void issue_dmi_req(struct dmidpi_ctx *ctx) {
  */
 static bool process_jtag_cmd(struct dmidpi_ctx *ctx, bool tdi, bool tms,
                              bool tck) {
-  // Return tdo values during tck low phase
-  if (!tck) {
-    if (ctx->jtag.jtag_state == ShiftDr) {
-      ctx->jtag.jtag_tdo = ctx->jtag.dr_shift_reg & 0x1;
-    } else {
-      ctx->jtag.jtag_tdo = ctx->jtag.ir_shift_reg & 0x1;
+    // Return tdo values during tck low phase
+    if (!tck) {
+        if (ctx->jtag.jtag_state == ShiftDr) {
+            ctx->jtag.jtag_tdo = ctx->jtag.dr_shift_reg & 0x1;
+        } else {
+            ctx->jtag.jtag_tdo = ctx->jtag.ir_shift_reg & 0x1;
+        }
+        return false;
+    }
+
+    // standard JTAG state machine
+    switch (ctx->jtag.jtag_state) {
+        case TestLogicReset:
+            // reset design
+            ctx->sig.dmi_rst_n = 0;
+            ctx->jtag.ir_captured = 1;
+            if (!tms) {
+                ctx->jtag.jtag_state = RunTestIdle;
+            }
+            return true;
+        case RunTestIdle:
+            // release reset
+            ctx->sig.dmi_rst_n = 1;
+            if (tms) {
+                ctx->jtag.jtag_state = SelectDrScan;
+            }
+            return false;
+        case SelectDrScan:
+            if (tms) {
+                ctx->jtag.jtag_state = SelectIrScan;
+            } else {
+                ctx->jtag.jtag_state = CaptureDr;
+            }
+            return false;
+        case CaptureDr:
+            set_dr_data(ctx);
+            if (tms) {
+                ctx->jtag.jtag_state = Exit1Dr;
+            } else {
+                ctx->jtag.jtag_state = ShiftDr;
+            }
+            return false;
+        case ShiftDr:
+            ctx->jtag.dr_shift_reg |= ((uint64_t)tdi << ctx->jtag.dr_length);
+            ctx->jtag.dr_shift_reg >>= 1;
+            if (tms) {
+                ctx->jtag.jtag_state = Exit1Dr;
+            }
+            return false;
+        case Exit1Dr:
+            if (tms) {
+                ctx->jtag.jtag_state = UpdateDr;
+            } else {
+                ctx->jtag.jtag_state = PauseDr;
+            }
+            return false;
+        case PauseDr:
+            if (tms) {
+                ctx->jtag.jtag_state = Exit2Dr;
+            }
+            return false;
+        case Exit2Dr:
+            if (tms) {
+                ctx->jtag.jtag_state = UpdateDr;
+            } else {
+                ctx->jtag.jtag_state = ShiftDr;
+            }
+            return false;
+        case UpdateDr:
+            ctx->jtag.dr_captured = ctx->jtag.dr_shift_reg;
+            if (tms) {
+                ctx->jtag.jtag_state = SelectDrScan;
+            } else {
+                ctx->jtag.jtag_state = RunTestIdle;
+            }
+            // If a DMI read or write completes, write it out
+            if ((ctx->jtag.ir_captured == DMIAccess) &&
+                ((ctx->jtag.dr_captured & 0x3) != 0)) {
+                issue_jtag_dmi_req(ctx);
+                return true;
+            }
+            return false;
+        case SelectIrScan:
+            if (tms) {
+                ctx->jtag.jtag_state = TestLogicReset;
+            } else {
+                ctx->jtag.jtag_state = CaptureIr;
+            }
+            return false;
+        case CaptureIr:
+            ctx->jtag.ir_shift_reg = 0x5;
+            if (tms) {
+                ctx->jtag.jtag_state = Exit1Ir;
+            } else {
+                ctx->jtag.jtag_state = ShiftIr;
+            }
+            return false;
+        case ShiftIr:
+            ctx->jtag.ir_shift_reg |= ((uint32_t)tdi << 5);
+            ctx->jtag.ir_shift_reg >>= 1;
+            if (tms) {
+                ctx->jtag.jtag_state = Exit1Ir;
+            }
+            return false;
+        case Exit1Ir:
+            if (tms) {
+                ctx->jtag.jtag_state = UpdateIr;
+            } else {
+                ctx->jtag.jtag_state = PauseIr;
+            }
+            return false;
+        case PauseIr:
+            if (tms) {
+                ctx->jtag.jtag_state = Exit2Ir;
+            }
+            return false;
+        case Exit2Ir:
+            if (tms) {
+                ctx->jtag.jtag_state = UpdateIr;
+            } else {
+                ctx->jtag.jtag_state = ShiftIr;
+            }
+            return false;
+        case UpdateIr:
+            ctx->jtag.ir_captured = ctx->jtag.ir_shift_reg;
+            if (tms) {
+                ctx->jtag.jtag_state = SelectDrScan;
+            } else {
+                ctx->jtag.jtag_state = RunTestIdle;
+            }
+            return false;
     }
     return false;
-  }
-
-  // standard JTAG state machine
-  switch (ctx->jtag.jtag_state) {
-    case TestLogicReset:
-      // reset design
-      ctx->sig.dmi_rst_n = 0;
-      ctx->jtag.ir_captured = 1;
-      if (!tms) {
-        ctx->jtag.jtag_state = RunTestIdle;
-      }
-      return true;
-    case RunTestIdle:
-      // release reset
-      ctx->sig.dmi_rst_n = 1;
-      if (tms) {
-        ctx->jtag.jtag_state = SelectDrScan;
-      }
-      return false;
-    case SelectDrScan:
-      if (tms) {
-        ctx->jtag.jtag_state = SelectIrScan;
-      } else {
-        ctx->jtag.jtag_state = CaptureDr;
-      }
-      return false;
-    case CaptureDr:
-      set_dr_data(ctx);
-      if (tms) {
-        ctx->jtag.jtag_state = Exit1Dr;
-      } else {
-        ctx->jtag.jtag_state = ShiftDr;
-      }
-      return false;
-    case ShiftDr:
-      ctx->jtag.dr_shift_reg |= ((uint64_t)tdi << ctx->jtag.dr_length);
-      ctx->jtag.dr_shift_reg >>= 1;
-      if (tms) {
-        ctx->jtag.jtag_state = Exit1Dr;
-      }
-      return false;
-    case Exit1Dr:
-      if (tms) {
-        ctx->jtag.jtag_state = UpdateDr;
-      } else {
-        ctx->jtag.jtag_state = PauseDr;
-      }
-      return false;
-    case PauseDr:
-      if (tms) {
-        ctx->jtag.jtag_state = Exit2Dr;
-      }
-      return false;
-    case Exit2Dr:
-      if (tms) {
-        ctx->jtag.jtag_state = UpdateDr;
-      } else {
-        ctx->jtag.jtag_state = ShiftDr;
-      }
-      return false;
-    case UpdateDr:
-      ctx->jtag.dr_captured = ctx->jtag.dr_shift_reg;
-      if (tms) {
-        ctx->jtag.jtag_state = SelectDrScan;
-      } else {
-        ctx->jtag.jtag_state = RunTestIdle;
-      }
-      // If a DMI read or write completes, write it out
-      if ((ctx->jtag.ir_captured == DMIAccess) &&
-          ((ctx->jtag.dr_captured & 0x3) != 0)) {
-        issue_dmi_req(ctx);
-        return true;
-      }
-      return false;
-    case SelectIrScan:
-      if (tms) {
-        ctx->jtag.jtag_state = TestLogicReset;
-      } else {
-        ctx->jtag.jtag_state = CaptureIr;
-      }
-      return false;
-    case CaptureIr:
-      ctx->jtag.ir_shift_reg = 0x5;
-      if (tms) {
-        ctx->jtag.jtag_state = Exit1Ir;
-      } else {
-        ctx->jtag.jtag_state = ShiftIr;
-      }
-      return false;
-    case ShiftIr:
-      ctx->jtag.ir_shift_reg |= ((uint32_t)tdi << 5);
-      ctx->jtag.ir_shift_reg >>= 1;
-      if (tms) {
-        ctx->jtag.jtag_state = Exit1Ir;
-      }
-      return false;
-    case Exit1Ir:
-      if (tms) {
-        ctx->jtag.jtag_state = UpdateIr;
-      } else {
-        ctx->jtag.jtag_state = PauseIr;
-      }
-      return false;
-    case PauseIr:
-      if (tms) {
-        ctx->jtag.jtag_state = Exit2Ir;
-      }
-      return false;
-    case Exit2Ir:
-      if (tms) {
-        ctx->jtag.jtag_state = UpdateIr;
-      } else {
-        ctx->jtag.jtag_state = ShiftIr;
-      }
-      return false;
-    case UpdateIr:
-      ctx->jtag.ir_captured = ctx->jtag.ir_shift_reg;
-      if (tms) {
-        ctx->jtag.jtag_state = SelectDrScan;
-      } else {
-        ctx->jtag.jtag_state = RunTestIdle;
-      }
-      return false;
-  }
-  return false;
 }
 
 /**
@@ -279,50 +302,52 @@ static bool process_jtag_cmd(struct dmidpi_ctx *ctx, bool tdi, bool tms,
  * @return true when a command completes, false otherwise
  */
 static bool process_cmd_byte(struct dmidpi_ctx *ctx, char cmd) {
-  /*
-   * Documentation pointer:
-   * The remote_bitbang protocol implemented below is documented in the OpenOCD
-   * source tree at doc/manual/jtag/drivers/remote_bitbang.txt, or online at
-   * https://repo.or.cz/openocd.git/blob/HEAD:/doc/manual/jtag/drivers/remote_bitbang.txt
-   */
-
-  // parse received command byte
-  if (cmd >= '0' && cmd <= '7') {
-    // JTAG write
-    char cmd_bit = cmd - '0';
-    char tdi = (cmd_bit >> 0) & 0x1;
-    char tms = (cmd_bit >> 1) & 0x1;
-    char tck = (cmd_bit >> 2) & 0x1;
-    return (process_jtag_cmd(ctx, tdi, tms, tck));
-  } else if (cmd >= 'r' && cmd <= 'u') {
-    // JTAG reset (active high from OpenOCD)
-    char cmd_bit = cmd - 'r';
-    char trst = ((cmd_bit >> 1) & 0x1);
-    if (trst) {
-      ctx->sig.dmi_rst_n = 0;
-      ctx->jtag.jtag_state = RunTestIdle;
-    }
-    return true;
-  } else if (cmd == 'R') {
-    // JTAG read, send tdo as response
-    char tdo_ascii = ctx->jtag.jtag_tdo + '0';
-    tcp_server_write(ctx->sock, tdo_ascii);
-  } else if (cmd == 'B') {
-    // printf("DMI DPI: BLINK ON!\n");
-  } else if (cmd == 'b') {
-    // printf("DMI DPI: BLINK OFF!\n");
-  } else if (cmd == 'Q') {
-    // quit (client disconnect)
-    printf("DMI DPI: Remote disconnected.\n");
-    tcp_server_client_close(ctx->sock);
-  } else {
-    fprintf(stderr,
+    /*
+     * Documentation pointer:
+     * The remote_bitbang protocol implemented below is documented in the
+     * OpenOCD
+     * source tree at doc/manual/jtag/drivers/remote_bitbang.txt, or online at
+     * https://repo.or.cz/openocd.git/blob/HEAD:/doc/manual/jtag/drivers/remote_bitbang.txt
+     */
+
+    // parse received command byte
+    if (cmd >= '0' && cmd <= '7') {
+        // JTAG write
+        char cmd_bit = cmd - '0';
+        char tdi = (cmd_bit >> 0) & 0x1;
+        char tms = (cmd_bit >> 1) & 0x1;
+        char tck = (cmd_bit >> 2) & 0x1;
+        return (process_jtag_cmd(ctx, tdi, tms, tck));
+    } else if (cmd >= 'r' && cmd <= 'u') {
+        // JTAG reset (active high from OpenOCD)
+        char cmd_bit = cmd - 'r';
+        char trst = ((cmd_bit >> 1) & 0x1);
+        if (trst) {
+            ctx->sig.dmi_rst_n = 0;
+            ctx->jtag.jtag_state = RunTestIdle;
+        }
+        return true;
+    } else if (cmd == 'R') {
+        // JTAG read, send tdo as response
+        char tdo_ascii = ctx->jtag.jtag_tdo + '0';
+        tcp_server_write(ctx->sock, tdo_ascii);
+    } else if (cmd == 'B') {
+        // printf("DMI DPI: BLINK ON!\n");
+    } else if (cmd == 'b') {
+        // printf("DMI DPI: BLINK OFF!\n");
+    } else if (cmd == 'Q') {
+        // quit (client disconnect)
+        printf("DMI DPI: Remote disconnected.\n");
+        tcp_server_client_close(ctx->sock);
+    } else {
+        fprintf(
+            stderr,
             "DMI DPI: Protocol violation detected: unsupported command %c\n",
             cmd);
-    exit(1);
-  }
+        exit(1);
+    }
 
-  return false;
+    return false;
 }
 
 /**
@@ -331,18 +356,95 @@ static bool process_cmd_byte(struct dmidpi_ctx *ctx, char cmd) {
  * @param ctx dmidpi context object
  */
 static void process_dmi_inputs(struct dmidpi_ctx *ctx) {
-  // Deassert dmi_req_valid when acked
-  if (ctx->sig.dmi_req_ready) {
-    ctx->sig.dmi_req_valid = 0;
-  }
-  // Always ready for a resp
-  ctx->sig.dmi_rsp_ready = 1;
-  if (ctx->sig.dmi_rsp_valid) {
-    ctx->jtag.dr_captured = (uint64_t)ctx->sig.dmi_rsp_data << 2;
-    ctx->jtag.dr_captured |= (uint64_t)ctx->sig.dmi_rsp_resp & 0x3;
-    // Clear req outstanding flag
-    ctx->jtag.dmi_outstanding = 0;
-  }
+    // Deassert dmi_req_valid when acked
+    if (ctx->sig.dmi_req_ready) {
+        ctx->sig.dmi_req_valid = 0;
+    }
+    // Always ready for a resp
+    ctx->sig.dmi_rsp_ready = 1;
+    if (ctx->sig.dmi_rsp_valid && ctx->jtag.dmi_outstanding) {
+        ctx->jtag.dr_captured = (uint64_t)ctx->sig.dmi_rsp_data << 2;
+        ctx->jtag.dr_captured |= (uint64_t)ctx->sig.dmi_rsp_resp & 0x3;
+        // Clear req outstanding flag
+        ctx->jtag.dmi_outstanding = 0;
+    }
+
+    if (ctx->sig.dmi_rsp_valid && ctx->dtm.dmi_outstanding) {
+        // Clear req outstanding flag
+        ctx->dtm.dmi_outstanding = 0;
+        ctx->dtm.dmi_captured = 1;
+    }
+}
+
+/**
+ * Issues a DMI request and then waits to advance after a short timeout
+ *
+ * @param ctx dmidpi context object
+ */
+static void issue_dtm_req_and_advance(struct dmidpi_ctx *ctx, uint64_t address,
+                                      uint64_t data, enum dtm_state_t state) {
+    if (!ctx->dtm.dmi_outstanding && !ctx->dtm.dmi_captured) {
+        ctx->dtm.dmi_captured = 0;
+        ctx->dtm.dmi_outstanding = 1;
+        ctx->dtm.dmi_timeout = 10;
+        ctx->sig.dmi_req_valid = 1;
+        ctx->sig.dmi_req_addr = address;
+        ctx->sig.dmi_req_data = data;
+    }
+
+    if (ctx->dtm.dmi_captured && !(ctx->dtm.dmi_timeout--)) {
+        ctx->dtm.dmi_captured = 0;
+        ctx->dtm.dtm_state = state;
+    }
+}
+
+/**
+ * Process DTM request
+ * @param ctx dmidpi context object
+ */
+static void process_dtm_debug_req(struct dmidpi_ctx *ctx) {
+    int sbcs_write = 0;
+    sbcs_write |= (0x00 << 20);  // SBReadOnAddr
+    sbcs_write |= (0x02 << 17);  // SBAccess
+    sbcs_write |= (0x00 << 16);  // SBAutoIncrement
+    sbcs_write |= (0x00 << 15);  // SBReadOnData
+    switch (ctx->dtm.dtm_state) {
+        case Ready:
+            ctx->dtm.dtm_state = StartReq;
+            break;
+        case StartReq:
+            ctx->dtm.dtm_state = SbaCfg;
+            break;
+        case SbaCfg:
+            issue_dtm_req_and_advance(ctx, 0x38, sbcs_write, SendNPC_A);
+            break;
+        case SendNPC_A:
+            issue_dtm_req_and_advance(ctx, 0x39, 0x200010, SendNPC_D);
+            break;
+        case SendNPC_D:
+            issue_dtm_req_and_advance(ctx, 0x3C, 0x130800, SendHiReq_A);
+            break;
+        case SendHiReq_A:
+            issue_dtm_req_and_advance(ctx, 0x39, 0x30c000, SendHiReq_D);
+            break;
+        case SendHiReq_D:
+            issue_dtm_req_and_advance(ctx, 0x3C, 0x1, SendLoReq_A);
+            break;
+        case SendLoReq_A:
+            issue_dtm_req_and_advance(ctx, 0x39, 0x30c000, SendLoReq_D);
+            break;
+        case SendLoReq_D:
+            issue_dtm_req_and_advance(ctx, 0x3C, 0x0, SendUnfreeze_A);
+            break;
+        case SendUnfreeze_A:
+            issue_dtm_req_and_advance(ctx, 0x39, 0x200008, SendUnfreeze_D);
+            break;
+        case SendUnfreeze_D:
+            issue_dtm_req_and_advance(ctx, 0x3C, 0x0, EndReq);
+            break;
+        case EndReq:
+            break;
+    }
 }
 
 /**
@@ -351,60 +453,67 @@ static void process_dmi_inputs(struct dmidpi_ctx *ctx) {
  * @param ctx dmidpi context object
  */
 static void update_dmi_state(struct dmidpi_ctx *ctx) {
-  assert(ctx);
-
-  // read input from design
-  process_dmi_inputs(ctx);
-
-  // If we are waiting for a previous transaction to complete, do not attempt
-  // a new one
-  if (ctx->jtag.dmi_outstanding) {
-    return;
-  }
-
-  char done = 0;
-  while (!done) {
-    // read a command byte
-    char cmd;
-    if (!tcp_server_read(ctx->sock, &cmd)) {
-      return;
+    assert(ctx);
+
+    // read input from design
+    process_dmi_inputs(ctx);
+
+    // If we are waiting for a previous transaction to complete, do not attempt
+    // a new one
+    if (ctx->jtag.dmi_outstanding || ctx->dtm.dmi_outstanding) {
+        return;
+    }
+
+    // If there is a debug req, we need to trigger debug entry
+    // TODO: Need to process JTAG commands here once we're done
+    if (ctx->dtm.dtm_state > Ready && ctx->dtm.dtm_state < EndReq) {
+        process_dtm_debug_req(ctx);
+        return;
+    }
+
+    char done = 0;
+    while (!done) {
+        // read a command byte
+        char cmd;
+        if (!tcp_server_read(ctx->sock, &cmd)) {
+            return;
+        }
+        // Process command bytes until a command completes
+        done = process_cmd_byte(ctx, cmd);
     }
-    // Process command bytes until a command completes
-    done = process_cmd_byte(ctx, cmd);
-  }
 }
 
 void *dmidpi_create(const char *display_name, int listen_port) {
-  // Create context
-  struct dmidpi_ctx *ctx =
-      (struct dmidpi_ctx *)calloc(1, sizeof(struct dmidpi_ctx));
-  assert(ctx);
-
-  // Set up socket details
-  ctx->sock = tcp_server_create(display_name, listen_port);
-
-  printf(
-      "\n"
-      "JTAG: Virtual JTAG interface %s is listening on port %d. Use\n"
-      "OpenOCD and the following configuration to connect:\n"
-      "  interface remote_bitbang\n"
-      "  remote_bitbang_host localhost\n"
-      "  remote_bitbang_port %d\n",
-      display_name, listen_port, listen_port);
-
-  return (void *)ctx;
+    // Create context
+    struct dmidpi_ctx *ctx =
+        (struct dmidpi_ctx *)calloc(1, sizeof(struct dmidpi_ctx));
+    assert(ctx);
+
+    // Set up socket details
+    ctx->sock = tcp_server_create(display_name, listen_port);
+
+    printf(
+        "\n"
+        "JTAG: Virtual JTAG interface %s is listening on port %d. Use\n"
+        "OpenOCD and the following configuration to connect:\n"
+        "  interface remote_bitbang\n"
+        "  remote_bitbang_host localhost\n"
+        "  remote_bitbang_port %d\n",
+        display_name, listen_port, listen_port);
+
+    return (void *)ctx;
 }
 
 void dmidpi_close(void *ctx_void) {
-  struct dmidpi_ctx *ctx = (struct dmidpi_ctx *)ctx_void;
-  if (!ctx) {
-    return;
-  }
+    struct dmidpi_ctx *ctx = (struct dmidpi_ctx *)ctx_void;
+    if (!ctx) {
+        return;
+    }
 
-  // Shut down the server
-  tcp_server_close(ctx->sock);
+    // Shut down the server
+    tcp_server_close(ctx->sock);
 
-  free(ctx);
+    free(ctx);
 }
 
 void dmidpi_tick(void *ctx_void, svBit *dmi_req_valid,
@@ -412,24 +521,33 @@ void dmidpi_tick(void *ctx_void, svBit *dmi_req_valid,
                  svBitVecVal *dmi_req_op, svBitVecVal *dmi_req_data,
                  const svBit dmi_rsp_valid, svBit *dmi_rsp_ready,
                  const svBitVecVal *dmi_rsp_data,
-                 const svBitVecVal *dmi_rsp_resp, svBit *dmi_rst_n) {
-  struct dmidpi_ctx *ctx = (struct dmidpi_ctx *)ctx_void;
-
-  if (!ctx) {
-    return;
-  }
-
-  ctx->sig.dmi_req_ready = dmi_req_ready;
-  ctx->sig.dmi_rsp_valid = dmi_rsp_valid;
-  ctx->sig.dmi_rsp_data = *dmi_rsp_data;
-  ctx->sig.dmi_rsp_resp = *dmi_rsp_resp;
-
-  update_dmi_state(ctx);
-
-  *dmi_req_valid = ctx->sig.dmi_req_valid;
-  *dmi_req_addr = ctx->sig.dmi_req_addr;
-  *dmi_req_op = ctx->sig.dmi_req_op;
-  *dmi_req_data = ctx->sig.dmi_req_data;
-  *dmi_rsp_ready = ctx->sig.dmi_rsp_ready;
-  *dmi_rst_n = ctx->sig.dmi_rst_n;
+                 const svBitVecVal *dmi_rsp_resp, svBit *dmi_rst_n,
+                 const svBit debug_req) {
+    struct dmidpi_ctx *ctx = (struct dmidpi_ctx *)ctx_void;
+
+    if (!ctx) {
+        return;
+    }
+
+    ctx->sig.dmi_req_ready = dmi_req_ready;
+    ctx->sig.dmi_rsp_valid = dmi_rsp_valid;
+    ctx->sig.dmi_rsp_data = *dmi_rsp_data;
+    ctx->sig.dmi_rsp_resp = *dmi_rsp_resp;
+
+    if (debug_req && ctx->dtm.dtm_state == Ready) {
+        ctx->dtm.dtm_state = StartReq;
+    }
+    if (!debug_req && ctx->dtm.dtm_state == EndReq) {
+        ctx->dtm.dtm_state = Ready;
+    }
+
+    update_dmi_state(ctx);
+
+    *dmi_req_valid = ctx->sig.dmi_req_valid;
+    *dmi_req_addr = ctx->sig.dmi_req_addr;
+    *dmi_req_op = ctx->sig.dmi_req_op;
+    *dmi_req_data = ctx->sig.dmi_req_data;
+    *dmi_rsp_ready = ctx->sig.dmi_rsp_ready;
+    *dmi_rst_n = ctx->sig.dmi_rst_n;
 }
+
diff --git a/hw/dv/dpi/dmidpi/dmidpi.h b/hw/dv/dpi/dmidpi/dmidpi.h
index 64d9c76..8e8f2db 100644
--- a/hw/dv/dpi/dmidpi/dmidpi.h
+++ b/hw/dv/dpi/dmidpi/dmidpi.h
@@ -44,7 +44,7 @@ void dmidpi_tick(void *ctx_void, svBit *dmi_req_valid,
                  svBitVecVal *dmi_req_op, svBitVecVal *dmi_req_data,
                  const svBit dmi_resp_valid, svBit *dmi_resp_ready,
                  const svBitVecVal *dmi_resp_data,
-                 const svBitVecVal *dmi_resp_resp, svBit *dmi_reset_n);
+                 const svBitVecVal *dmi_resp_resp, svBit *dmi_reset_n, const svBit debug_req);
 
 #ifdef __cplusplus
 }  // extern "C"
diff --git a/hw/dv/dpi/dmidpi/dmidpi.sv b/hw/dv/dpi/dmidpi/dmidpi.sv
index 856a4b2..4757cac 100644
--- a/hw/dv/dpi/dmidpi/dmidpi.sv
+++ b/hw/dv/dpi/dmidpi/dmidpi.sv
@@ -18,7 +18,9 @@ module dmidpi #(
   output bit        dmi_rsp_ready,
   input  bit [31:0] dmi_rsp_data,
   input  bit [1:0]  dmi_rsp_resp,
-  output bit        dmi_rst_n
+  output bit        dmi_rst_n,
+
+  input bit         debug_req
 );
 
   import "DPI-C"
@@ -30,7 +32,7 @@ module dmidpi #(
                             output bit [1:0] dmi_req_op, output bit [31:0] dmi_req_data,
                             input bit dmi_rsp_valid, output bit dmi_rsp_ready,
                             input bit [31:0] dmi_rsp_data, input bit [1:0] dmi_rsp_resp,
-                            output bit dmi_rst_n);
+                            output bit dmi_rst_n, input bit debug_req);
 
   import "DPI-C"
   function void dmidpi_close(input chandle ctx);
@@ -49,7 +51,7 @@ module dmidpi #(
   always_ff @(posedge clk_i, negedge rst_ni) begin
     dmidpi_tick(ctx, dmi_req_valid, dmi_req_ready, dmi_req_addr, dmi_req_op,
                 dmi_req_data, dmi_rsp_valid, dmi_rsp_ready, dmi_rsp_data,
-                dmi_rsp_resp, dmi_rst_n);
+                dmi_rsp_resp, dmi_rst_n, debug_req);
   end
 
 endmodule
-- 
2.16.5

